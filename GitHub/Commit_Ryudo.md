# コミットの粒度

[【初心者向け】「コミットの粒度がわからない問題」の模範解答を考えてみた - Qiita](https://qiita.com/jnchito/items/40e0c7d32fde352607be)

[Web制作者のための実践Git | 第1回 適切な履歴の作り方](https://www.codegrid.net/articles/git-tech-1/)

# **良いコミットメッセージ、悪いコミットメッセージ**

> まずは「なぜ」その変更を行ったかを記録するための**コミットメッセージ**について解説します。Gitを使っているユーザーであれば普段からコミットメッセージは書いているはずです。
> 
> 
> 
> コミットメッセージは、変更履歴をあとからみたときに、どのような変更を行ったのかをすばやく認識するためのものです。したがって、どのような変更だったのかが一目で見てわからないコミットメッセージはあまり意味のないものになります。
> 
> たとえば次のようなコミットメッセージは悪い例です。
> 
> `バグ修正`
> 
> このコミットメッセージは何のバグをどのように修正したのか、まったくわからず、結局変更のdiffを見ることになるため、コミットメッセージとしてはほとんど意味がありません。次のようにすればどうでしょう。
> 
> `User APIのageフィールドの値がない場合にエラーになるバグを修正`
> 
> これであればひと目で、どのような修正を行ったのかがわかります。これは良いコミットメッセージといえます。
> 
> 次に以下の例を見てください。
> 
> `Ajaxのタイムアウト値を5000msから10000msに変更`
> 
> これは「何を」変更したのかが書かれていて悪くはないのですが、もっと詳しく書くことでコミットメッセージとしての価値がより上がります。この例が良くない点は「なぜ10000msにしたか」ということが書かれていないことです。
> 
> このような場合、1行目に概要を書き、ひとつ空行を置いて、3行目からその詳細を書くという、Gitの標準的なコミットメッセージのフォーマットで書くのがよいでしょう。たとえば次のように書きます。
> 
> `Ajaxのタイムアウト値を5000msから10000msに変更5000msでタイムアウトすると、モバイルなどの3G環境下でタイムアウトが頻発するため10000msに変更した。`
> 
> このように書いてあればコミットメッセージをみただけで、「なぜ変更したのか」がすぐわかります。
> 
> 他の人が見た時にコミットメッセージを見るだけで、変更の内容がおおむね把握できることを心がけて書くといいかもしれません。ひとりで開発している場合でも、未来の自分は変更を覚えていない可能性が高いので、そういったケースでも有効になるはずです。
> 

# **コミットの粒度の適切さ**

> 次に、ひとつのコミットで「何を」変更したかを適切に記録するためにはどうすればいいのかを見ていきましょう。何を変更したかを適切に記録するということは、ひとつひとつのコミットの粒度が適切であるということです。
> 
> 
> 
> たとえば次のようなコミットはよくありません。
> 
> `機能Aの追加と機能Bのバグ修正`
> 
> 「機能Aの追加」と「機能Bのバグ修正」という2つの変更がひとつのコミットに混ざっています。基本的にひとつのコミットに2つ以上の変更を含めるべきではありません。
> 
> たとえば、あとからやはり機能Aは必要なかったから元に戻したいとなった場合、「機能Aの追加」と「機能Bのバグ修正」というコミットが別々になっていれば、`git revert`コマンドで「機能Aの追加」のコミットを取り消すことができます。
> 
> しかしこの2つの変更が同じコミットになっていると、「機能Aの追加」だけ元に戻したいのに、「機能Bのバグ修正」まで元に戻ってしまいます。このように、Gitの機能の恩恵をより多くうけるために、ひとつのコミットを適切な粒度で行う必要があるのです。
> 
> 次に、以下のようなコミットがあったとします。
> 
> `検索機能の実装`
> 
> このコミットにはサーバーサイドのAPIの実装からJavaScript、HTML、CSSのフロントエンド実装のすべてが含まれていたとしましょう。たしかにひとつのコミットで、ひとまとまりの変更という原則は守られていますが、このコミットは粒度が大きすぎます。このような比較的大きな機能の実装はコミットではなく、ブランチにするのが適当な粒度です。
> 
> こういったケースにおいて、「このような単位でコミットするべきである」というベストプラクティスがあるわけではありませんが、「Entryモデルのsearchメソッド実装」など、ひとつひとつの小さい機能ごとにコミットを作っていくのがベターではないかと思います。
> 
> コミットの粒度に関しても、コミットメッセージの場合と同じように、あとから他の人が見て変更の意図がわかりやすく、履歴として意味のあるものにすることを心がけることが大切です。
> 

# **git add -p**

> `git add -p`というコマンドを使うと、同じファイルであっても、変更を選択してステージング（インデックスに追加）することができます。コマンドを実行すると次のような画面になります。
> 
> 
> 
> `$ git add -pdiff --git a/sample.html b/sample.htmlindex 0bb7f2e..3c1f17e 100644--- a/sample.html+++ b/sample.html**@@ -1,5 +1,9 @@** <ul>   <li><a href="/">Home</a></li>-  <li><a href="/about.html">About</a>+  <li><a href="/about.html">About</a></li>   <li><a href="/help.html">Help</a></li> </ul>++<div class="content">+  contents...+</div>Stage this hunk [y,n,q,a,d,/,s,e,?]?`
> 
> ここで何かキー入力することで、この変更をどうするか選択することができます。選択できるキーは一番下に表示されているもので、それぞれ次のような意味があります。
> 
> | キー | 意味 |
> | --- | --- |
> | y | この変更をステージングする |
> | n | この変更をステージングしない |
> | q | 終了する |
> | a | これ以降の変更をすべてステージングする |
> | d | これ以降の変更をすべてステージングしない |
> | / | 正規表現で変更内容の検索を行う |
> | s | この変更をさらに分割する |
> | e | この変更の分割をエディタを起動して手動で行う |
> | ? | ヘルプを表示する |
> 
> 上記の例の場合、変更した箇所が近いため同じhunk（変更の塊）として表示されています。ですので、hunkをさらに分割する必要があります。そのためには`s`を選択します。そうすると次のような表示になります。
> 
> `Split into 2 hunks.**@@ -1,5 +1,5 @@** <ul>   <li><a href="/">Home</a></li>-  <li><a href="/about.html">About</a>+  <li><a href="/about.html">About</a></li>   <li><a href="/help.html">Help</a></li> </ul>Stage this hunk [y,n,q,a,d,/,j,J,g,e,?]?`
> 
> 変更が分割されて閉じタグ忘れだけの変更が表示されています。ここで`y`を押してこの変更をステージングします。すると次は以下の表示になります。
> 
> **`@@ -4,2 +4,6 @@**   <li><a href="/help.html">Help</a></li> </ul>++<div class="content">+  contents...+</div>Stage this hunk [y,n,q,a,d,/,K,g,e,?]?`
> 
> こんどはコンテンツの追加ですから、ここでは`n`を選択してこの変更はステージングしません。そうすると、同じファイルに対して同時に2つの変更を行ったにもかかわらず、一部の変更だけがステージングされている状態になります。
> 
> この状態で`git commit`でコミットすれば、閉じタグの修正だけがコミットされます。あとは残りのコンテンツ追加をコミットすれば、無事2つのコミットとして履歴に記録されます。
> 
> `git add -p`コマンドを使うと複数の変更を行ったあとでも、適切な粒度でコミットを作ることができるので、とても便利です。
>
